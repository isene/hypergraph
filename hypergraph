#!/usr/bin/env ruby
# encoding: utf-8
#
# HyperGraph v2.0 - Enhanced HyperList graphing tool
# Author: Geir Isene <g@isene.com>
# Enhanced version with modular architecture and new features

require 'fileutils'
require 'getoptlong'
require 'json'
require 'pathname'

# Add lib directory to load path
lib_path = File.expand_path('../lib', __FILE__)
$LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)

require_relative 'lib/hypergraph/parser'
require_relative 'lib/hypergraph/graph_generator'

VERSION = "2.0.0"

class HyperGraphCLI
  def initialize
    @options = load_defaults
    @config_file = File.expand_path('~/.hypergraphrc')
    load_config if File.exist?(@config_file)
  end

  def load_defaults
    {
      type: 'state',
      direction: 'TB',
      arrows: true,
      spline: 'spline',
      format: 'png',
      theme: 'default',
      validate_only: false,
      watch: false,
      verbose: false,
      overwrite: false,
      clean: false,
      sep: nil,
      output: nil,
      interactive: false
    }
  end

  def load_config
    begin
      config = JSON.parse(File.read(@config_file), symbolize_names: true)
      @options.merge!(config)
      puts "Loaded config from #{@config_file}" if @options[:verbose]
    rescue JSON::ParserError => e
      warn "Warning: Invalid config file #{@config_file}: #{e.message}"
    end
  end

  def save_config
    File.write(@config_file, JSON.pretty_generate(@options))
    puts "Configuration saved to #{@config_file}"
  end

  def parse_arguments
    opts = GetoptLong.new(
      ['--help',        '-h', GetoptLong::NO_ARGUMENT],
      ['--version',     '-v', GetoptLong::NO_ARGUMENT],
      ['--state',       '-s', GetoptLong::NO_ARGUMENT],
      ['--trans',       '-t', GetoptLong::NO_ARGUMENT],
      ['--down',        '-d', GetoptLong::NO_ARGUMENT],
      ['--up',          '-u', GetoptLong::NO_ARGUMENT],
      ['--left',        '-l', GetoptLong::NO_ARGUMENT],
      ['--right',       '-r', GetoptLong::NO_ARGUMENT],
      ['--arrow',       '-a', GetoptLong::NO_ARGUMENT],
      ['--noarrow',     '-n', GetoptLong::NO_ARGUMENT],
      ['--ortho',       '-o', GetoptLong::NO_ARGUMENT],
      ['--poly',        '-p', GetoptLong::NO_ARGUMENT],
      ['--sep',         '-e', GetoptLong::REQUIRED_ARGUMENT],
      ['--format',      '-f', GetoptLong::REQUIRED_ARGUMENT],
      ['--theme',       '-T', GetoptLong::REQUIRED_ARGUMENT],
      ['--output',      '-O', GetoptLong::REQUIRED_ARGUMENT],
      ['--clean',       '-c', GetoptLong::NO_ARGUMENT],
      ['--validate',    '-V', GetoptLong::NO_ARGUMENT],
      ['--watch',       '-w', GetoptLong::NO_ARGUMENT],
      ['--verbose',     '-b', GetoptLong::NO_ARGUMENT],
      ['--interactive', '-i', GetoptLong::NO_ARGUMENT],
      ['--save-config', '-S', GetoptLong::NO_ARGUMENT],
      ['--overwrite',   '-W', GetoptLong::NO_ARGUMENT]
    )

    save_config_flag = false

    opts.each do |opt, arg|
      case opt
      when '--help'
        show_help
        exit 0
      when '--version'
        puts "hypergraph version #{VERSION}"
        exit 0
      when '--state'
        @options[:type] = 'state'
      when '--trans'
        @options[:type] = 'trans'
      when '--down'
        @options[:direction] = 'TB'
      when '--up'
        @options[:direction] = 'BT'
      when '--left'
        @options[:direction] = 'LR'
      when '--right'
        @options[:direction] = 'RL'
      when '--arrow'
        @options[:arrows] = true
      when '--noarrow'
        @options[:arrows] = false
      when '--ortho'
        @options[:spline] = 'ortho'
      when '--poly'
        @options[:spline] = 'polyline'
      when '--sep'
        @options[:sep] = arg
      when '--format'
        @options[:format] = arg
      when '--theme'
        @options[:theme] = arg
      when '--output'
        @options[:output] = arg
      when '--clean'
        @options[:clean] = true
      when '--validate'
        @options[:validate_only] = true
      when '--watch'
        @options[:watch] = true
      when '--verbose'
        @options[:verbose] = true
      when '--interactive'
        @options[:interactive] = true
      when '--save-config'
        save_config_flag = true
      when '--overwrite'
        @options[:overwrite] = true
      end
    end

    save_config if save_config_flag

    @input_file = ARGV[0]
    
    if !@input_file && !@options[:interactive]
      show_help
      exit 1
    end
  end

  def show_help
    puts <<~HELP
      HyperGraph v#{VERSION} - Enhanced HyperList graphing tool
      
      USAGE
        hypergraph [OPTIONS] filename.hl
        
      OPTIONS
        HyperList type:
          -s, --state           Treat as State (hierarchy)
          -t, --trans           Treat as Transition (sequence)
          
        Chart direction:
          -d, --down            Top-to-bottom (DEFAULT)
          -u, --up              Bottom-to-top
          -l, --left            Left-to-right
          -r, --right           Right-to-left
          
        Edge type:
          -a, --arrow           Use directional arrows (DEFAULT)
          -n, --noarrow         Use non-directional lines
          -o, --ortho           Use angled lines
          -p, --poly            Use straight lines
          
        Visual options:
          -e, --sep VALUE       Set node/rank separation
          -T, --theme THEME     Use theme: default, business, tech, pastel
          
        Output options:
          -f, --format FORMAT   Output format: png (default), jpg, svg, pdf, html
          -O, --output FILE     Output filename (default: auto-generated)
          -W, --overwrite       Overwrite existing files
          
        Processing options:
          -c, --clean           Only output clean/strict HyperList
          -V, --validate        Validate syntax only (no graph output)
          -w, --watch           Watch file and auto-regenerate on changes
          -i, --interactive     Interactive mode (enter HyperList via stdin)
          
        Other options:
          -b, --verbose         Verbose output
          -S, --save-config     Save current options as defaults
          -h, --help            Show this help
          -v, --version         Show version
          
      THEMES
        default   - Classic black and white
        business  - Professional blue theme
        tech      - Matrix-style green on black
        pastel    - Soft pastel colors
        
      EXAMPLES
        hypergraph -s -f svg todo.hl
        hypergraph -t --theme business process.hl
        hypergraph --validate mylist.hl
        hypergraph -w -O output.png tasks.hl
        
      CONFIG FILE
        Settings saved in ~/.hypergraphrc
    HELP
  end

  def run
    parse_arguments

    if @options[:interactive]
      run_interactive
    elsif @options[:watch]
      run_watch_mode
    else
      process_file(@input_file)
    end
  end

  def run_interactive
    puts "Enter HyperList (Ctrl+D to finish):"
    content = $stdin.read
    
    process_content(content, "interactive")
  end

  def run_watch_mode
    require 'listen'
    
    puts "Watching #{@input_file} for changes... (Ctrl+C to stop)"
    
    # Initial processing
    process_file(@input_file)
    
    dir = File.dirname(@input_file)
    file = File.basename(@input_file)
    
    listener = Listen.to(dir) do |modified, added, removed|
      if modified.any? { |f| File.basename(f) == file }
        puts "\nFile changed, regenerating..."
        process_file(@input_file)
      end
    end
    
    listener.start
    sleep
  rescue LoadError
    puts "Error: Watch mode requires the 'listen' gem. Install with: gem install listen"
    exit 1
  rescue Interrupt
    puts "\nStopping watch mode."
  end

  def process_file(filename)
    unless File.exist?(filename)
      puts "Error: File '#{filename}' not found"
      exit 1
    end

    content = File.read(filename)
    basename = File.basename(filename, File.extname(filename))
    
    process_content(content, basename)
  end

  def process_content(content, basename)
    # Parse HyperList
    parser = HyperGraph::Parser.new(content)
    parsed_lines = parser.parse

    # Show errors and warnings
    if parser.errors.any?
      puts "\n❌ Errors found:"
      parser.errors.each do |error|
        puts "  Line #{error[:line]}: #{error[:message]}"
      end
      exit 1 if @options[:validate_only]
    end

    if parser.warnings.any? && @options[:verbose]
      puts "\n⚠️  Warnings:"
      parser.warnings.each do |warning|
        puts "  Line #{warning[:line]}: #{warning[:message]}"
      end
    end

    if @options[:validate_only]
      puts "✅ HyperList validation successful!"
      puts "  #{parsed_lines.length} items parsed"
      return
    end

    # Save clean/strict version
    if @options[:clean] || !@options[:validate_only]
      strict_content = generate_strict_hyperlist(parsed_lines)
      strict_file = get_output_filename(basename, "_strict.hl")
      
      if strict_content != content
        File.write(strict_file, strict_content)
        puts "Clean HyperList saved: #{strict_file}" if @options[:verbose]
      end
      
      return if @options[:clean]
    end

    # Generate graph
    generator = HyperGraph::GraphGenerator.new(parsed_lines, @options)
    dot_content = generator.generate

    # Save DOT file
    dot_file = get_output_filename(basename, ".dot")
    File.write(dot_file, dot_content)
    puts "DOT file created: #{dot_file}" if @options[:verbose]

    # Generate output based on format
    output_file = @options[:output] || get_output_filename(basename, ".#{@options[:format]}")
    
    case @options[:format]
    when 'html'
      generate_html_output(parsed_lines, output_file)
    else
      generate_graphviz_output(dot_file, output_file, @options[:format])
    end
  end

  def generate_strict_hyperlist(parsed_lines)
    lines = []
    
    parsed_lines.each do |item|
      line = "\t" * item[:level]
      
      # Add type if present
      if item[:type]
        line += item[:type] == :state ? "S: " : "T: "
      end
      
      # Add qualifiers
      item[:qualifiers].each do |qual|
        line += "[#{qual[:raw]}] "
      end
      
      # Add operators
      item[:operators].each do |op|
        line += "#{op}: "
      end
      
      # Add properties
      item[:properties].each do |key, value|
        next if ['color', 'fillcolor', 'fontcolor'].include?(key)
        line += "#{key} = #{value}: "
      end
      
      # Add main text
      line += item[:display_text]
      
      # Add references
      item[:references][:hard].each do |ref|
        line += " <#{ref}>"
      end
      
      item[:references][:soft].each do |ref|
        line += " (<#{ref}>)"
      end
      
      # Add tags
      item[:tags].each do |tag|
        line += " ##{tag}"
      end
      
      # Add color properties at end
      ['color', 'fillcolor', 'fontcolor'].each do |prop|
        if item[:properties][prop]
          line += " (#{prop}=#{item[:properties][prop]})"
        end
      end
      
      lines << line
    end
    
    lines.join("\n")
  end

  def get_output_filename(basename, extension)
    if @options[:overwrite]
      return basename + extension
    end
    
    filename = basename + extension
    counter = 1
    
    while File.exist?(filename)
      filename = "#{basename}_#{counter}#{extension}"
      counter += 1
    end
    
    filename
  end

  def generate_graphviz_output(dot_file, output_file, format)
    cmd = "dot -T#{format} \"#{dot_file}\" -o \"#{output_file}\""
    
    puts "Executing: #{cmd}" if @options[:verbose]
    
    success = system(cmd)
    
    if success
      puts "✅ Graph generated: #{output_file}"
    else
      puts "❌ Error generating graph. Make sure Graphviz is installed."
      exit 1
    end
  end

  def generate_html_output(parsed_lines, output_file)
    html_content = generate_interactive_html(parsed_lines)
    File.write(output_file, html_content)
    puts "✅ Interactive HTML generated: #{output_file}"
  end

  def generate_interactive_html(parsed_lines)
    # This would include D3.js visualization
    # For now, a simple placeholder
    <<~HTML
      <!DOCTYPE html>
      <html>
      <head>
        <title>HyperGraph Interactive</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
          body { font-family: Arial, sans-serif; }
          .node { cursor: pointer; }
          .node circle { fill: #fff; stroke: steelblue; stroke-width: 3px; }
          .node text { font: 12px sans-serif; }
          .link { fill: none; stroke: #ccc; stroke-width: 2px; }
        </style>
      </head>
      <body>
        <h1>HyperGraph Interactive Visualization</h1>
        <div id="graph"></div>
        <script>
          // D3.js visualization code would go here
          // This is a placeholder for the full implementation
          document.getElementById('graph').innerHTML = 
            '<p>Interactive visualization coming soon!</p>' +
            '<p>Parsed #{parsed_lines.length} HyperList items</p>';
        </script>
      </body>
      </html>
    HTML
  end
end

# Run the CLI
if __FILE__ == $0
  cli = HyperGraphCLI.new
  cli.run
end